#!/bin/sh
#\
umask 022; exec /usr/bin/tclsh "$0" "$@"

# $Id$

################################################################################

# Copyright Â© 2012, Alan M. Watson. All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
# * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# 
# * Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
# 
# * The names of its contributors may not be used to endorse or promote
# products derived from this software without specific prior written
# permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

################################################################################

package require Tclx

################################################################################

set logdir "$env(HOME)/.ssh/"

################################################################################

proc getlines {file} {
  set channel [open $file "r"]
  set lines {}
  while {true} {
    set line [gets $channel]
    if {[eof $channel]} {
      break
    }
    set line [regsub -all {\t} $line " "]
    set line [regsub -all {^ +} $line ""]
    set line [regsub -all { +$} $line ""]
    set line [regsub -all { +} $line " "]
    lappend lines [split $line]
  }
  close $channel
  return $lines
}

proc gethostdict {} {

  set hostdict {}

  foreach line [getlines "$::env(HOME)/.ssh/config"] {
    if {[string equal -nocase [lindex $line 0] "host"]} {
      set currenthosts [lrange $line 1 end]
      foreach host $currenthosts {
        dict set hostdict $host "configured" true
      }
      foreach host $currenthosts {
        switch -glob $host {
          "*-tunnel" {
  	    dict set hostdict $host "type" "tunnel"
  	  }
          default {
            dict set hostdict $host "type" "ssh"
          }
        }
      }
    } elseif {[string equal -nocase [lindex $line 0] "#tunneldependency"]} {
      foreach host $currenthosts {
        if {![dict exists $hostdict $host "dependency"]} {
          dict set hostdict $host "dependency" [lindex $line 1]
        }
      }
    } elseif {[string equal -nocase [lindex $line 0] "#tunnelopenatstartup"] &&
              [string equal [lindex $line 1] "yes"]} {
      foreach host $currenthosts {
        if {![dict exists $hostdict $host "openatstartup"]} {
          dict set hostdict $host "openatstartup" true
        }
      }
    } elseif {[string equal -nocase [lindex $line 0] "#tunnelopenatstartup"] &&
              [string equal [lindex $line 1] "no"]} {
      foreach host $currenthosts {
        if {![dict exists $hostdict $host "openatstartup"]} {
          dict set hostdict $host "openatstartup" false
        }
      }
    }
  }
  
  foreach line [getlines "|launchctl list"] {
    if {[regexp {^ssh-tunnel\..+} [lindex $line 2]]} {
      set host [regsub {^ssh-tunnel\.} [lindex $line 2] ""]
      dict set hostdict $host "open" true
    }
  }
  
  foreach host [dict keys $hostdict] {
    if {![dict exists $hostdict $host "configured"]} {
      dict set hostdict $host "configured" false
    }
    if {![dict exists $hostdict $host "dependency"]} {
      dict set hostdict $host "dependency" ""
    }
    if {![dict exists $hostdict $host "openatstartup"]} {
      dict set hostdict $host "openatstartup" false
    }
    if {![dict exists $hostdict $host "open"]} {
      dict set hostdict $host "open" false
    }
  }
  
  return $hostdict
}

set hostdict [gethostdict]

proc sethost {host key value} {
  global hostdict
  dict set hostdict $host $key $value
}

proc gethost {host key} {
  global hostdict
  if {[string equal $key "exists"]} {
    dict exists $hostdict $host
  } else {
    dict get $hostdict $host $key
  }
}

proc gethosts {} {
  global hostdict
  dict keys $hostdict
}

################################################################################

proc openssh {argv} {
  set host [lindex $argv 0]
  puts stderr "host is \"$host\"."
  puts stderr "dependency is \"[gethost $host "dependency"]\"."
  if {![string equal [gethost $host "dependency"] ""]} {
    opentunnel [gethost $host "dependency"]
  }
  execl "/usr/bin/ssh" $argv
}

################################################################################

proc opentunnel {tunnel} {
  if {![gethost $tunnel "open"]} {
    if {![string equal [gethost $tunnel "dependency"] ""]} {
      opentunnel [gethost $tunnel "dependency"]
    }
    exec -ignorestderr -- \
      "/bin/launchctl" "submit" "-l" "ssh-tunnel.$tunnel" \
      "-e" "$::logdir/topo-log-$tunnel.txt" \
       "--" \
       "/usr/bin/ssh" "-N" "$tunnel"
    sethost $tunnel "open" true
  }
}

################################################################################

proc closetunnel {tunnel} {
  if {[gethost $tunnel "open"]} {
    exec -ignorestderr -- \
      "/bin/launchctl" "remove" "ssh-tunnel.$tunnel"
    sethost $tunnel "open" false
  }
}

################################################################################

proc yesorno {value} {
  if {$value} {
    return "yes"
  } else {
    return "no"
  }
}

proc listsubcommand {} {
  set format "%-23s %-10s %-23s %-11s %-5s %s"
  puts [format $format "Host" "Type" "Dependency" "Configured?" "Open?" "OpenAtStartup?"]
  puts [format $format "====" "====" "==========" "===========" "=====" "=============="]
  foreach host [gethosts] {
    switch [gethost $host "type"] {
      "tunnel" {
        puts [format $format \
          $host \
          [gethost $host "type"] \
          [gethost $host "dependency"] \
          [yesorno [gethost $host "configured"]] \
          [yesorno [gethost $host "open"]] \
          [yesorno [gethost $host "openatstartup"]] \
        ]
      }
      "ssh"  {
        puts [format $format \
          $host \
          [gethost $host "type"] \
          [gethost $host "dependency"] \
          [yesorno [gethost $host "configured"]] \
	  "" \
	  "" \
        ]
      }
    }
  }
}

################################################################################

set scriptdir "$env(HOME)/Library/Scripts/Topo"

# From the FastScripts documentation:
# 
# Starting in version 2.2.5, FastScripts will arrange menu items in a
# user-specified order based on a common convention followed by BBEdit
# and others. If the file or folder name starts with any two characters
# and a ')', then the characters are used to control the relative
# placement of the item. For instance, a script named "AA)Zounds" will
# show up as "Zounds" in the menu but be placed above an item named
# "Apples". FastScripts will also respect the "menu separator"
# convention - when a folder's name ends in "-***", its contents are
# ignored and a menu separator line is inserted where its name would
# ordinarily appear.
# 
# See http://www.red-sweater.com/RedSweater/FSFeatures.html
# 
# These features are not supported by the standard Apple Script Menu, so
# we only use them if FastScripts is either running or is configured to
# run at start up.

set fastscriptsrunning [exec "/bin/sh" "-c" {
  if /bin/launchctl list | /usr/bin/grep -q '\.com\.red-sweater\.FastScripts$'
  then
    echo true
  else
    echo false
  fi
}]

set fastscriptsrunsatstartup [exec "/bin/sh" "-c" {
  if /usr/bin/plutil -convert xml1 -o - \
    $HOME/Library/Preferences/loginwindow.plist | \
    /usr/bin/grep -q '<string>/Applications/FastScripts\.app</string>'
  then
    echo true
  else
    echo false
  fi
}]

set fastscripts [expr {$fastscriptsrunning || $fastscriptsrunsatstartup}]

proc makescript {subpath argv} {
  global fastscripts
  if {!$fastscripts} {
    set subpath [regsub {^..\)} $subpath ""]
    set subpath [regsub {/..\)} $subpath "/"]
  }
  global scriptdir
  set path [file join $scriptdir $subpath]
  file mkdir [file dirname $path]
  set channel [open $path "w" "0744"]
  puts $channel "#!/bin/sh"
  puts -nonewline $channel "exec /usr/bin/topo" 
  foreach arg $argv {
    puts -nonewline $channel " \"[regsub -all {[$'"`]} $arg {\\&}]\""
  }
  puts $channel ""
  close $channel
}

proc makescriptseparator {subpath} {
  global fastscripts
  if {$fastscripts} {
    global scriptdir
    set path [file join $scriptdir "$subpath-***"]
    file mkdir $path
  }
}

proc refreshscriptmenus {} {
  global scriptdir
  if {[file isdirectory $scriptdir]} {
    exec "/bin/rm" "-rf" "$scriptdir"
    foreach host [gethosts] {
      if {[string equal [gethost $host "type"] "tunnel"] && 
          [gethost $host "open"]} {
        set prefix [regsub -- {-tunnel$} $host ""]
        makescript "BB)Close.../AA)$prefix" [list close "$host"]
      }
    }
    makescriptseparator "AA)Open.../BB)"
    makescript          "AA)Open.../CC)All" [list "openall"]
    foreach host [gethosts] {
      if {[string equal [gethost $host "type"] "tunnel"] && 
          ![gethost $host "open"] && 
          [gethost $host "configured"]} {
        set prefix [regsub -- {-tunnel$} $host ""]
        makescript "AA)Open.../AA)$prefix" [list open $host]
      }
    }
    makescriptseparator "BB)Close.../BB)"
    makescript          "BB)Close.../CC)All" [list "closeall"]
    makescriptseparator "CC)"
    makescript          "DD)Restart" [list "startup"]
  }
}

proc installscripts {} {
  global scriptdir
  exec "/bin/rm" "-rf" "$scriptdir"
  file mkdir $scriptdir
  refreshscriptmenus
}

################################################################################

proc fatalerror {message} {
  puts "error: $message"
  exit 1
}

################################################################################

proc checkhostexists {tunnel} {
  if {![gethost $tunnel "exists"]} {
    fatalerror "tunnel \"$tunnel\" does not exist."
  }
}

proc checkhostconfigured {tunnel} {
  checkhostexists $tunnel
  if {![gethost $tunnel "configured"]} {
    fatalerror "tunnel \"$tunnel\" is not configured."
  }
}

################################################################################

proc opensubcommand {argv} {
  checkargc $argv 1 0
  set host [lindex $argv 0]
  checkhostexists $host
  checkhostconfigured $host
  switch [gethost $host "type"] {
    "tunnel" {
      checkargc $argv 1 1
      opentunnel $host
      refreshscriptmenus
    }
    "ssh" {
      checkargc $argv 1 0
      openssh $argv
    }
  }
}

proc openallsubcommand {} {
  foreach tunnel [gethosts] {
    opentunnel $tunnel
  }
  refreshscriptmenus
}

proc closesubcommand {tunnels} {
  foreach tunnel $tunnels {
    checkhostexists $tunnel
    checkhostconfigured $tunnel
  }
  foreach tunnel $tunnels {
    closetunnel $tunnel
  }
  refreshscriptmenus
}

proc closeallsubcommand {} {
  foreach tunnel [gethosts] {
    closetunnel $tunnel
  }
  refreshscriptmenus
}

proc startupsubcommand {} {
  set opentunnels {}
  foreach tunnel [gethosts] {
    if {[gethost $tunnel "open"] && [gethost $tunnel "configured"]} {
      lappend opentunnels $tunnel
    }
  }
  foreach tunnel [gethosts] {
    closetunnel $tunnel
  }
  foreach tunnel [gethosts] {
    if {[gethost $tunnel "openatstartup"]} {
      opentunnel $tunnel
    }
  }
  foreach tunnel $opentunnels {
    opentunnel $tunnel
  }
  refreshscriptmenus
}

proc installscriptssubcommand {} {
  installscripts
}

proc checkargc {argv min max} {
  set argc [llength $argv]
  set subcommand [lindex $argv 0]
  if {$min > 0 && $argc < $min} {
    fatalerror "$subcommand: too few arguments."
  }
  if {$max > 0 && $argc > $max} {
    fatalerror "$subcommand: too many arguments."
  }
}

proc main {argv} {
  switch [lindex $argv 0] {
    "open" {
      opensubcommand [lrange $argv 1 end]
    }
    "close" {
      checkargc $argv 2 0
      closesubcommand [lrange $argv 1 end]
    }
    "openall" {
      checkargc $argv 1 1
      openallsubcommand
    }
    "closeall" {
      checkargc $argv 1 1
      closeallsubcommand
    }
    "startup" {
      checkargc $argv 1 1
      startupsubcommand
    }
    "list" {
      checkargc $argv 1 1
      listsubcommand
    }
    "installscripts" {
      checkargc $argv 1 1
      installscriptssubcommand
    }
    "" {
      fatalerror "missing subcommand."
    }
    default {
      fatalerror "invalid subcommand \"[lindex $argv 0]\"."
    }
  }
  exit 0
}

main $argv

################################################################################
