#!/bin/sh
#\
umask 022; exec /usr/bin/tclsh "$0" "$@"

# $Id$

################################################################################

# Copyright Â© 2012, Alan M. Watson. All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
# * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# 
# * Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
# 
# * The names of its contributors may not be used to endorse or promote
# products derived from this software without specific prior written
# permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

################################################################################

package require Tclx

################################################################################

set logdir "$env(HOME)/.ssh/"

################################################################################

namespace eval host {

  variable dict {}

  proc set {key subkey value} {
    variable dict
    if {![dict exists $dict $key]} {
      dict set dict $key {}
    }
    dict set dict $key $subkey $value
  }

  proc get {key subkey} {
    variable dict
    dict get $dict $key $subkey
  }

  proc exists {key {subkey ""}} {
    variable dict
    if {[string equal $subkey ""]} {
      dict exists $dict $key
    } else {
      dict exists [dict get $dict $key] $subkey
    }
  }

  proc keys {} {
    variable dict
    dict keys $dict
  }

}

################################################################################

namespace eval tunneledport {

  variable dict {}

  proc set {key subkey value} {
    variable dict
    if {![dict exists $dict $key]} {
      dict set dict $key {}
    }
    dict set dict $key $subkey $value
  }

  proc get {key subkey} {
    variable dict
    dict get $dict $key $subkey
  }

  proc exists {key {subkey ""}} {
    variable dict
    if {[string equal $subkey ""]} {
      dict exists $dict $key
    } else {
      dict exists [dict get $dict $key] $subkey
    }
  }

  proc keys {} {
    variable dict
    dict keys $dict
  }

}

################################################################################

namespace eval sshconfig {

  proc getlines {file} {
    set channel [open $file "r"]
    set lines {}
    while {true} {
      set line [gets $channel]
      if {[eof $channel]} {
        break
      }
      set line [regsub -all {\t} $line " "]
      set line [regsub -all {^ +} $line ""]
      set line [regsub -all { +$} $line ""]
      set line [regsub -all { +} $line " "]
      lappend lines [split $line]
    }
    close $channel
    return $lines
  }

  proc parse {} {

    foreach line [getlines "$::env(HOME)/.ssh/config"] {
      set keyword [string tolower [lindex $line 0]]
      switch $keyword {
        "host" {
          set currenthosts [lrange $line 1 end]
          foreach host $currenthosts {
            host::set $host "configured" true
            host::set $host "type" "ssh"
          }
        }
        "hostname" -
        "port" {
          foreach host $currenthosts {
            if {![host::exists $host $keyword]} {
              host::set $host $keyword [lindex $line 1]
            }
          }
        }
        "#tunnelopenatstartup" {
          if {[string equal [lindex $line 1] "yes"]} {
            foreach host $currenthosts {
              if {![host::exists $host "openatstartup"]} {
                host::set $host "openatstartup" true
              }
            }
          } elseif {[string equal [lindex $line 1] "no"]} {
            foreach host $currenthosts {
              if {![host::exists $host "openatstartup"]} {
                host::set $host "openatstartup" false
              }
            }
          }
        }
        "localforward" {
          set tunneledport [lindex $line 1]
          if {[llength $currenthosts] != 1} {
            fatalerror "tunnels must have only one host pattern."
          }
          set host $currenthosts
          host::set $host "type" "tunnel"
          tunneledport::set $tunneledport "tunnel" $host
        }
      }
    }
  
    foreach line [getlines "|launchctl list"] {
      if {[regexp {^ssh-tunnel\..+} [lindex $line 2]]} {
        set host [regsub {^ssh-tunnel\.} [lindex $line 2] ""]
        host::set $host "open" true
      }
    }
  
    foreach host [host::keys] {
      foreach {keyword value} [list \
        "hostname"      $host \
        "port"          22 \
        "configured"    false \
        "openatstartup" false \
        "open"          false \
      ] {
        if {![host::exists $host $keyword]} {
          host::set $host $keyword $value
        }
      }
    }
  
  }

  parse
  
}  

################################################################################

proc openssh {argv} {
  set host [lindex $argv 0]
  openhostdependency $host
  execl "/usr/bin/ssh" $argv
}

################################################################################

proc getdependency {host} {
  set hostname [host::get $host "hostname"]
  if {![string equal $hostname "localhost"]} {
    return ""
  }
  set port [host::get $host "port"]
  if {![tunneledport::exists $port]} {
    return ""
  }
  set tunnel [tunneledport::get $port "tunnel"]
  return $tunnel
}

proc openhostdependency {host} {
  set dependency [getdependency $host]
  if {![string equal $dependency ""]} {
    opentunnel $dependency
  }
}

proc opentunnel {tunnel} {
  if {![host::get $tunnel "open"]} {
    openhostdependency $tunnel
    exec -ignorestderr -- \
      "/bin/launchctl" "submit" "-l" "ssh-tunnel.$tunnel" \
      "-e" "$::logdir/topo-log-$tunnel.txt" \
       "--" \
       "/usr/bin/ssh" "-N" "$tunnel"
    host::set $tunnel "open" true
  }
}

################################################################################

proc closetunnel {tunnel} {
  if {[host::get $tunnel "open"]} {
    exec -ignorestderr -- \
      "/bin/launchctl" "remove" "ssh-tunnel.$tunnel"
    host::set $tunnel "open" false
  }
}

################################################################################

proc yesorno {value} {
  if {$value} {
    return "yes"
  } else {
    return "no"
  }
}

proc listsubcommand {} {
  set format "%-31s %-10s %-31s %-11s %-31s %-5s %s"
  puts [format $format "Host" "Type" "Dependency" "Configured?" "Host:Port" "Open?" "OpenAtStartup?"]
  puts [format $format "====" "====" "==========" "===========" "=========" "=====" "=============="]
  foreach host [host::keys] {
    switch [host::get $host "type"] {
      "tunnel" {
        puts [format $format \
          $host \
          [host::get $host "type"] \
          [getdependency $host] \
          [yesorno [host::get $host "configured"]] \
          [host::get $host "hostname"]:[host::get $host "port"] \
          [yesorno [host::get $host "open"]] \
          [yesorno [host::get $host "openatstartup"]] \
        ]
      }
      "ssh"  {
        puts [format $format \
          $host \
          [host::get $host "type"] \
          [getdependency $host] \
          [yesorno [host::get $host "configured"]] \
          [host::get $host "hostname"]:[host::get $host "port"] \
    "" \
    "" \
        ]
      }
    }
  }
  set format "%-13s %-23s"
  puts [format $format "Tunneled Port" "Tunnel"]
  puts [format $format "=============" "======"]
  foreach tunneledport [tunneledport::keys] {
    puts [format $format \
      $tunneledport \
      [tunneledport::get $tunneledport "tunnel"] \
    ]
  }
}

################################################################################

set scriptdir "$env(HOME)/Library/Scripts/Topo"

# From the FastScripts documentation:
# 
# Starting in version 2.2.5, FastScripts will arrange menu items in a
# user-specified order based on a common convention followed by BBEdit
# and others. If the file or folder name starts with any two characters
# and a ')', then the characters are used to control the relative
# placement of the item. For instance, a script named "AA)Zounds" will
# show up as "Zounds" in the menu but be placed above an item named
# "Apples". FastScripts will also respect the "menu separator"
# convention - when a folder's name ends in "-***", its contents are
# ignored and a menu separator line is inserted where its name would
# ordinarily appear.
# 
# See http://www.red-sweater.com/RedSweater/FSFeatures.html
# 
# These features are not supported by the standard Apple Script Menu, so
# we only use them if FastScripts is either running or is configured to
# run at start up.

set fastscriptsrunning [exec "/bin/sh" "-c" {
  if /bin/launchctl list | /usr/bin/grep -q '\.com\.red-sweater\.FastScripts$'
  then
    echo true
  else
    echo false
  fi
}]

set fastscriptsrunsatstartup [exec "/bin/sh" "-c" {
  if /usr/bin/plutil -convert xml1 -o - \
    $HOME/Library/Preferences/loginwindow.plist | \
    /usr/bin/grep -q '<string>/Applications/FastScripts\.app</string>'
  then
    echo true
  else
    echo false
  fi
}]

set fastscripts [expr {$fastscriptsrunning || $fastscriptsrunsatstartup}]

proc makescript {subpath argv} {
  global fastscripts
  if {!$fastscripts} {
    set subpath [regsub {^..\)} $subpath ""]
    set subpath [regsub {/..\)} $subpath "/"]
  }
  global scriptdir
  set path [file join $scriptdir $subpath]
  file mkdir [file dirname $path]
  set channel [open $path "w" "0744"]
  puts $channel "#!/bin/sh"
  puts -nonewline $channel "exec /usr/bin/topo" 
  foreach arg $argv {
    puts -nonewline $channel " \"[regsub -all {[$'"`]} $arg {\\&}]\""
  }
  puts $channel ""
  close $channel
}

proc makescriptseparator {subpath} {
  global fastscripts
  if {$fastscripts} {
    global scriptdir
    set path [file join $scriptdir "$subpath-***"]
    file mkdir $path
  }
}

proc refreshscriptmenus {} {
  global scriptdir
  if {[file isdirectory $scriptdir]} {
    exec "/bin/rm" "-rf" "$scriptdir"
    foreach host [host::key] {
      if {[string equal [host::get $host "type"] "tunnel"] && 
          [host::get $host "open"]} {
        set prefix [regsub -- {-tunnel$} $host ""]
        makescript "BB)Close.../AA)$prefix" [list close "$host"]
      }
    }
    makescriptseparator "AA)Open.../BB)"
    makescript          "AA)Open.../CC)All" [list "openall"]
    foreach host [host::keys] {
      if {[string equal [host::get $host "type"] "tunnel"] && 
          ![host::get $host "open"] && 
          [host::get $host "configured"]} {
        set prefix [regsub -- {-tunnel$} $host ""]
        makescript "AA)Open.../AA)$prefix" [list open $host]
      }
    }
    makescriptseparator "BB)Close.../BB)"
    makescript          "BB)Close.../CC)All" [list "closeall"]
    makescriptseparator "CC)"
    makescript          "DD)Restart" [list "startup"]
  }
}

proc installscripts {} {
  global scriptdir
  exec "/bin/rm" "-rf" "$scriptdir"
  file mkdir $scriptdir
  refreshscriptmenus
}

################################################################################

proc fatalerror {message} {
  puts "error: $message"
  exit 1
}

################################################################################

proc checkhostexists {tunnel} {
  if {![host::exists $tunnel]} {
    fatalerror "tunnel \"$tunnel\" does not exist."
  }
}

proc checkhostconfigured {tunnel} {
  checkhostexists $tunnel
  if {![host::get $tunnel "configured"]} {
    fatalerror "tunnel \"$tunnel\" is not configured."
  }
}

################################################################################

proc opensubcommand {host} {
  checkhostexists $host
  checkhostconfigured $host
  switch [host::get $host "type"] {
    "tunnel" {
      opentunnel $host
    }
    default {
      openhostdependency $host
    }
  }
  refreshscriptmenus
}

proc openallsubcommand {} {
  foreach tunnel [host::keys] {
    opentunnel $tunnel
  }
  refreshscriptmenus
}

proc closesubcommand {tunnels} {
  foreach tunnel $tunnels {
    checkhostexists $tunnel
    checkhostconfigured $tunnel
  }
  foreach tunnel $tunnels {
    closetunnel $tunnel
  }
  refreshscriptmenus
}

proc closeallsubcommand {} {
  foreach tunnel [host::keys] {
    closetunnel $tunnel
  }
  refreshscriptmenus
}

proc sshsubcommand {argv} {
  set host [lindex $argv 0]
  checkhostexists $host
  checkhostconfigured $host
  openssh $argv
}

proc startupsubcommand {} {
  set opentunnels {}
  foreach tunnel [host::keys] {
    if {[host::get $tunnel "open"] && [host::get $tunnel "configured"]} {
      lappend opentunnels $tunnel
    }
  }
  foreach tunnel [host::keys] {
    closetunnel $tunnel
  }
  foreach tunnel [host::keys] {
    if {[host::get $tunnel "openatstartup"]} {
      opentunnel $tunnel
    }
  }
  foreach tunnel $opentunnels {
    opentunnel $tunnel
  }
  refreshscriptmenus
}

proc installscriptssubcommand {} {
  installscripts
}

proc checkargc {argv min max} {
  set argc [llength $argv]
  set subcommand [lindex $argv 0]
  if {$min > 0 && $argc < $min} {
    fatalerror "$subcommand: too few arguments."
  }
  if {$max > 0 && $argc > $max} {
    fatalerror "$subcommand: too many arguments."
  }
}

proc main {argv} {
  switch [lindex $argv 0] {
    "open" {
      checkargc $argv 2 2
      opensubcommand [lindex $argv 1]
    }
    "close" {
      checkargc $argv 2 0
      closesubcommand [lrange $argv 1 end]
    }
    "openall" {
      checkargc $argv 1 1
      openallsubcommand
    }
    "closeall" {
      checkargc $argv 1 1
      closeallsubcommand
    }
    "ssh" {
      checkargc $argv 2 0
      sshsubcommand [lrange $argv 1 end]
    }
    "startup" {
      checkargc $argv 1 1
      startupsubcommand
    }
    "list" {
      checkargc $argv 1 1
      listsubcommand
    }
    "installscripts" {
      checkargc $argv 1 1
      installscriptssubcommand
    }
    "" {
      fatalerror "missing subcommand."
    }
    default {
      fatalerror "invalid subcommand \"[lindex $argv 0]\"."
    }
  }
  exit 0
}

main $argv

################################################################################
