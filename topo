#!/bin/sh
#\
umask 022; exec /usr/bin/tclsh "$0" "$@"

# $Id$

################################################################################

# Copyright Â© 2012, Alan M. Watson. All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
# * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
# 
# * Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
# 
# * The names of its contributors may not be used to endorse or promote
# products derived from this software without specific prior written
# permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

################################################################################

set logdir "$env(HOME)/.ssh/"

################################################################################

proc getlines {file} {
  set channel [open $file "r"]
  set lines {}
  while {true} {
    set line [gets $channel]
    if {[eof $channel]} {
      break
    }
    set line [regsub -all {\t} $line " "]
    set line [regsub -all {^ +} $line ""]
    set line [regsub -all { +$} $line ""]
    set line [regsub -all { +} $line " "]
    lappend lines [split $line]
  }
  close $channel
  return $lines
}

proc gettunneldict {} {

  set tunneldict {}

  set currenttunnels {}
  foreach line [getlines "$::env(HOME)/.ssh/config"] {
    if {[string equal -nocase [lindex $line 0] "host"]} {
      set currenttunnels {}
      foreach host [lrange $line 1 end] {
        if {[string match {*-tunnel} $host]} {
          lappend currenttunnels $host
        }
      }
      foreach tunnel $currenttunnels {
        dict set tunneldict $tunnel "configured" true
      }
    } elseif {[string equal -nocase [lindex $line 0] "#tunneldependency"]} {
      foreach tunnel $currenttunnels {
        if {![dict exists $tunneldict $tunnel "dependency"]} {
          dict set tunneldict $tunnel "dependency" [lindex $line 1]
        }
      }
    } elseif {[string equal -nocase [lindex $line 0] "#tunnelopenatstartup"] &&
              [string equal [lindex $line 1] "yes"]} {
      foreach tunnel $currenttunnels {
        if {![dict exists $tunneldict $tunnel "openatstartup"]} {
          dict set tunneldict $tunnel "openatstartup" true
        }
      }
    } elseif {[string equal -nocase [lindex $line 0] "#tunnelopenatstartup"] &&
              [string equal [lindex $line 1] "no"]} {
      foreach tunnel $currenttunnels {
        if {![dict exists $tunneldict $tunnel "openatstartup"]} {
          dict set tunneldict $tunnel "openatstartup" false
        }
      }
    }
  }
  
  foreach line [getlines "|launchctl list"] {
    if {[regexp {^ssh-tunnel\..+} [lindex $line 2]]} {
      set tunnel [regsub {^ssh-tunnel\.} [lindex $line 2] ""]
      dict set tunneldict $tunnel "open" true
    }
  }
  
  foreach tunnel [dict keys $tunneldict] {
    if {![dict exists $tunneldict $tunnel "configured"]} {
      dict set tunneldict $tunnel "configured" false
    }
    if {![dict exists $tunneldict $tunnel "dependency"]} {
      dict set tunneldict $tunnel "dependency" ""
    }
    if {![dict exists $tunneldict $tunnel "openatstartup"]} {
      dict set tunneldict $tunnel "openatstartup" false
    }
    if {![dict exists $tunneldict $tunnel "open"]} {
      dict set tunneldict $tunnel "open" false
    }
  }
  
  return $tunneldict
}

set tunneldict [gettunneldict]

proc settunnel {tunnel key value} {
  global tunneldict
  dict set tunneldict $tunnel $key $value
}

proc gettunnel {tunnel key} {
  global tunneldict
  if {[string equal $key "exists"]} {
    dict exists $tunneldict $tunnel
  } else {
    dict get $tunneldict $tunnel $key
  }
}

proc gettunnels {} {
  global tunneldict
  dict keys $tunneldict
}

################################################################################

proc opentunnel {tunnel} {
  if {![gettunnel $tunnel "open"]} {
    if {![string equal [gettunnel $tunnel "dependency"] ""]} {
      opentunnel [gettunnel $tunnel "dependency"]
    }
    exec -ignorestderr -- \
      "/bin/launchctl" "submit" "-l" "ssh-tunnel.$tunnel" \
      "-e" "$::logdir/topo-log-$tunnel.txt" \
       "--" \
       "/usr/bin/ssh" "-N" "$tunnel"
    settunnel $tunnel "open" true
  }
}

################################################################################

proc closetunnel {tunnel} {
  if {[gettunnel $tunnel "open"]} {
    exec -ignorestderr -- \
      "/bin/launchctl" "remove" "ssh-tunnel.$tunnel"
    settunnel $tunnel "open" false
  }
}

################################################################################

proc yesorno {value} {
  if {$value} {
    return "yes"
  } else {
    return "no"
  }
}

proc listsubcommand {} {
  set format "%-23s %-23s %-11s %-5s %s"
  puts [format $format "Tunnel" "Dependency" "Configured?" "Open?" "OpenAtStartup?"]
  puts [format $format "======" "==========" "===========" "=====" "=============="]
  foreach tunnel [gettunnels] {
    puts [format $format \
      $tunnel \
      [gettunnel $tunnel "dependency"] \
      [yesorno [gettunnel $tunnel "configured"]] \
      [yesorno [gettunnel $tunnel "open"]] \
      [yesorno [gettunnel $tunnel "openatstartup"]] \
    ]
  }
}

################################################################################

set scriptdir "$env(HOME)/Library/Scripts/Topo"

# From the FastScripts documentation:
# 
# Starting in version 2.2.5, FastScripts will arrange menu items in a
# user-specified order based on a common convention followed by BBEdit
# and others. If the file or folder name starts with any two characters
# and a ')', then the characters are used to control the relative
# placement of the item. For instance, a script named "AA)Zounds" will
# show up as "Zounds" in the menu but be placed above an item named
# "Apples". FastScripts will also respect the "menu separator"
# convention - when a folder's name ends in "-***", its contents are
# ignored and a menu separator line is inserted where its name would
# ordinarily appear.
# 
# See http://www.red-sweater.com/RedSweater/FSFeatures.html
# 
# These features are not supported by the standard Apple Script Menu, so
# we only use them if FastScripts is either running or is configured to
# run at start up.

set fastscriptsrunning [exec "/bin/sh" "-c" {
  if /bin/launchctl list | /usr/bin/grep -q '\.com\.red-sweater\.FastScripts$'
  then
    echo true
  else
    echo false
  fi
}]

set fastscriptsrunsatstartup [exec "/bin/sh" "-c" {
  if /usr/bin/plutil -convert xml1 -o - \
    $HOME/Library/Preferences/loginwindow.plist | \
    /usr/bin/grep -q '<string>/Applications/FastScripts\.app</string>'
  then
    echo true
  else
    echo false
  fi
}]

set fastscripts [expr {$fastscriptsrunning || $fastscriptsrunsatstartup}]

proc makescript {subpath argv} {
  global fastscripts
  if {!$fastscripts} {
    set subpath [regsub {^..\)} $subpath ""]
    set subpath [regsub {/..\)} $subpath "/"]
  }
  global scriptdir
  set path [file join $scriptdir $subpath]
  file mkdir [file dirname $path]
  set channel [open $path "w" "0744"]
  puts $channel "#!/bin/sh"
  puts -nonewline $channel "exec /usr/bin/topo" 
  foreach arg $argv {
    puts -nonewline $channel " \"[regsub -all {[$'"`]} $arg {\\&}]\""
  }
  puts $channel ""
  close $channel
}

proc makescriptseparator {subpath} {
  global fastscripts
  if {$fastscripts} {
    global scriptdir
    set path [file join $scriptdir "$subpath-***"]
    file mkdir $path
  }
}

proc refreshscriptmenus {} {
  global scriptdir
  if {[file isdirectory $scriptdir]} {
    exec "/bin/rm" "-rf" "$scriptdir"
    foreach tunnel [gettunnels] {
      if {[gettunnel $tunnel "open"]} {
        set prefix [regsub -- {-tunnel$} $tunnel ""]
        makescript "BB)Close.../AA)$prefix" [list close "$tunnel"]
      }
    }
    makescriptseparator "AA)Open.../BB)"
    makescript          "AA)Open.../CC)All" [list "openall"]
    foreach tunnel [gettunnels] {
      if {![gettunnel $tunnel "open"] && [gettunnel $tunnel "configured"]} {
        set prefix [regsub -- {-tunnel$} $tunnel ""]
        makescript "AA)Open.../AA)$prefix" [list open $tunnel]
      }
    }
    makescriptseparator "BB)Close.../BB)"
    makescript          "BB)Close.../CC)All" [list "closeall"]
    makescriptseparator "CC)"
    makescript          "DD)Restart" [list "startup"]
  }
}

proc installscripts {} {
  global scriptdir
  exec "/bin/rm" "-rf" "$scriptdir"
  file mkdir $scriptdir
  refreshscriptmenus
}

################################################################################

proc fatalerror {message} {
  puts "error: $message"
  exit 1
}

################################################################################

proc checktunnelexists {tunnel} {
  if {![gettunnel $tunnel "exists"]} {
    fatalerror "tunnel \"$tunnel\" does not exist."
  }
}

proc checktunnelconfigured {tunnel} {
  checktunnelexists $tunnel
  if {![gettunnel $tunnel "configured"]} {
    fatalerror "tunnel \"$tunnel\" is not configured."
  }
}

################################################################################

proc opensubcommand {tunnels} {
  foreach tunnel $tunnels {
    checktunnelexists $tunnel
    checktunnelconfigured $tunnel
  }
  foreach tunnel $tunnels {
    opentunnel $tunnel
  }
  refreshscriptmenus
}

proc openallsubcommand {} {
  foreach tunnel [gettunnels] {
    opentunnel $tunnel
  }
  refreshscriptmenus
}

proc closesubcommand {tunnels} {
  foreach tunnel $tunnels {
    checktunnelexists $tunnel
    checktunnelconfigured $tunnel
  }
  foreach tunnel $tunnels {
    closetunnel $tunnel
  }
  refreshscriptmenus
}

proc closeallsubcommand {} {
  foreach tunnel [gettunnels] {
    closetunnel $tunnel
  }
  refreshscriptmenus
}

proc startupsubcommand {} {
  set opentunnels {}
  foreach tunnel [gettunnels] {
    if {[gettunnel $tunnel "open"] && [gettunnel $tunnel "configured"]} {
      lappend opentunnels $tunnel
    }
  }
  foreach tunnel [gettunnels] {
    closetunnel $tunnel
  }
  foreach tunnel [gettunnels] {
    if {[gettunnel $tunnel "openatstartup"]} {
      opentunnel $tunnel
    }
  }
  foreach tunnel $opentunnels {
    opentunnel $tunnel
  }
  refreshscriptmenus
}

proc installscriptssubcommand {} {
  installscripts
}

proc checkargc {argv min max} {
  set argc [llength $argv]
  set subcommand [lindex $argv 0]
  if {$min > 0 && $argc < $min} {
    fatalerror "$subcommand: too few arguments."
  }
  if {$max > 0 && $argc > $max} {
    fatalerror "$subcommand: too many arguments."
  }
}

proc main {argv} {
  switch [lindex $argv 0] {
    "open" {
      checkargc $argv 2 0
      opensubcommand [lrange $argv 1 end]
    }
    "close" {
      checkargc $argv 2 0
      closesubcommand [lrange $argv 1 end]
    }
    "openall" {
      checkargc $argv 1 1
      openallsubcommand
    }
    "closeall" {
      checkargc $argv 1 1
      closeallsubcommand
    }
    "startup" {
      checkargc $argv 1 1
      startupsubcommand
    }
    "list" {
      checkargc $argv 1 1
      listsubcommand
    }
    "installscripts" {
      checkargc $argv 1 1
      installscriptssubcommand
    }
    "" {
      fatalerror "missing subcommand."
    }
    default {
      fatalerror "invalid subcommand \"[lindex $argv 0]\"."
    }
  }
  exit 0
}

main $argv

################################################################################
